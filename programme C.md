# **<u>Programme</u> C** 

(for examen in 25/09/2024) 

## 四个考试要点：

- Pointeur (pas de malloc)

- Structure

- Variables statique (clonnes)

- Tableau (pas de malloc)

  

### 1. 指针（Pointeur）

#### a. 变量和存储

首先，指针是一种**变量**，用于存储另一个变量的**内存地址**，而不是具体的值。

```
int *p //p是一个指向整数型的指针
```

#### b. 初始化

指针**初始化**，是通常指向一个已经存在的变量地址，用&获得变量地址

```
int num = 10;
int *p = &num;
//注意，这里不能写成int *p = num!!
```

#### c. *解引用

访问指针指向的值，通过***解引用**（déréférencement），访问或修改指向的变量值。
`*p = num` 

```
int num = 10;
int *p = &num;
printf("num = %d\n", *p);
*p = 20;
printf("num = %d\n", num);
```

#### d. 指针和数组

```
int tab[5] = {1,2,3,4,5};  //tab本身代表数组的起始地址，即数组第一个元素的地址&tab[0]
int *p = tab;          // 等同于 int *p = &arr[0];
printf("%d\n", *tab);  // 输出数组的第一个元素，等同于 tab[0].*tab = *p
//遍历数组
for (int i = 0; i < 5; i++) {
    printf("%d ", *(tab + i)); // 等同于 printf("%d ", tab[i]);
}
```

在这里我提出了一个问题，`*tab`是第一个元素的地址，为什么可以+i？*

##### 指针运算

这里涉及到指针的运算，`tab + i` 其实是 tab 的地址加上i * 元素大小

=>  `tab 地址 + i * sizeof(元素类型)`    

 对于 `int` 类型数组，`sizeof(int)` 通常为 `4` 字节。

##### example

假设 `tab 的起始地址为 `1000`，则：

- `tab + 0` 指向地址 `1000`，即 `arr[0]`
- `tab + 1` 指向地址 `1004`，即 `arr[1]`
- `tab + 2` 指向地址 `1008`，即 `arr[2]`
- 依此类推。

`*(tab + i)` 就是获取数组中第i个元素的值。

##### 总结

**数组名的特性**：在表达式中，数组名会被转换为指向其第一个元素的指针。

**指针算术**：允许在指针上进行加法运算，移动指针的位置。

**元素大小的考虑**：指针加法会自动根据指向类型的大小调整地址。

**解引用获取值**：`*(ptr)` 获取指针所指向地址的值。

#### e. 指针作为函数参数

##### 地址传递

```
void increment(int *n) {
    (*n)++;
}

int main() {
    int value = 5;
    increment(&value);
    printf("value = %d\n", value); // 输出：value = 6
    return 0;
}
```

这段代码中，函数期望接受一个指向整数型的指针`(int *n)`,  所以不能传入类型不兼容的类型。

##### 值传递

***<u>！！！如果，想直接传递值，而不是结果，函数一定要有返回类型，不能是void！！</u>***

```
// 修改后的函数，接收 int 类型，返回 int 类型
int increment(int n) {
    n++;
    return n;
}

int main() {
    int value = 5;
    value = increment(value); // 接收返回的新值。 
    //！！如果这里是increment(value),那么输出的值就仍是5
    printf("value = %d\n", value); // 输出：value = 6
    return 0;
}
```

##### **值传递与引用传递的区别**

- **值传递（传值调用）：**
  - 将变量的值复制一份传递给函数，函数内部的修改不会影响原始变量。
  - **但是**，由于我们 **将函数的返回值赋给了 `value`**，所以 `value` 被更新为新的值。
- **引用传递（传址调用）：**
  - 传递变量的地址（指针）给函数，函数可以通过指针修改原始变量的值。
  - 例如，传递 `int *` 类型的指针。

##### **指针的注意事项**

- **指针一定要初始化**：使用未初始化的指针会导致未定义的行为，可能导致程序崩溃。（可以通过指向const，已有变量地址，数组的首元素，函数，结构体，NULL，还有字符串字面量（不能修改），当然，还有malloc。）
- **空指针**：可以将指针初始化为`NULL`，表示它不指向任何有效的内存地址。
- **野指针**：指向已释放或未分配内存的指针，使用它们会产生严重错误。

#### f. QCM错题

1. L'opérateur `*` ...

   est l'opérateur de **déréférencement**.

   est un opérateur **unaire**.

   

2. ```
   int a;
   int *p;
   p = &a;
   ```

   P permet d'obtenir la valeur de `a` : `int n = *p;`

   **说法：**`p` 可以用于获取 `a` 的值：`int n = *p;`

   **分析：**

   - `p` 是指向 `a` 的指针，`*p` 解引用后得到 `a` 的值。
   - 通过 `int n = *p;`，将 `a` 的值赋给了新变量 `n`。

   **结论：**

   - **正确。** 由于 `p` 指向 `a`，所以 `*p` 可以获取 `a` 的值。

   P permet de modifier la valeur de `a` : `*p = 3;`

   **说法：**`p` 可以用于修改 `a` 的值：`*p = 3;`

   **分析：**

   - `*p` 解引用指针 `p`，指向变量 `a`。
   - 通过 `*p = 3;`，将值 `3` 赋给了 `a`。
   - 这直接修改了 `a` 的值为 `3`。

   **结论：**

   - **正确。** 使用 `*p` 可以修改 `a` 的值。

   P permet d'obtenir l'adresse de `a` : `printf("adresse de a : %p\n", p);`

   **说法：**`p` 可以用于获取 `a` 的地址：`printf("a 的地址：%p\n", p);`

   **分析：**

   - `p` 存储了 `a` 的地址，因为 `p = &a;`。
   - 使用 `printf("%p\n", p);` 可以输出 `p` 中存储的地址，即 `a` 的地址。

   **结论：**

   - **正确。** `p` 可以用于获取并输出 `a` 的地址。

3. 